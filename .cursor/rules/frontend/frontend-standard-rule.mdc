---
description: >
globs:
alwaysApply: true
---
---
description: >
  Core frontend engineering standards and structured reasoning process for Next.js 15 and React 19.
  This rule orchestrates all frontend development patterns and references specialized domain rules.
globs:
  - "frontend/**/*.{ts,tsx,js,jsx}"
alwaysApply: true
---

# Frontend Engineering Standards (Core Orchestrator)

## Analysis Process

Before responding to any request, follow these steps:

1. **Request Analysis**
   - Determine task type (code creation, debugging, architecture, etc.)
   - Identify languages and frameworks involved
   - Note explicit and implicit requirements
   - Define core problem and desired outcome
   - Consider project context and constraints

2. **Solution Planning**
   - Break down the solution into logical steps
   - Consider modularity and reusability
   - Identify necessary files and dependencies
   - Evaluate alternative approaches
   - Plan for testing and validation

3. **Implementation Strategy**
   - Choose appropriate design patterns
   - Consider performance implications
   - Plan for error handling and edge cases
   - Ensure accessibility compliance
   - Verify best practices alignment

---

## Code Style and Structure

### General Principles

- Write concise, readable TypeScript code
- Use functional and declarative programming patterns
- Follow DRY (Don't Repeat Yourself)
- Prefer early returns to reduce nesting
- Structure: main exports → subcomponents → helpers → types

### Naming Conventions

- Follow the established naming conventions defined in `naming-convention-rule.mdc`
- Use descriptive variable names that clearly indicate purpose and state
- Ensure React-specific patterns align with overall project standards

### TypeScript Usage

- Enforce TypeScript across the codebase
- Prefer `interface` over `type` for object shapes
- Avoid `enum` in favor of const maps
- Use the `satisfies` operator for literal type constraints
- Emphasize strict null safety and type inference

---

## Core Frontend Architecture Principles

### React Server Components First
- **Minimize `use client` usage** - Default to Server Components
- **Minimize `useEffect` and `setState`** - Favor RSC patterns
- **Wrap client components in Suspense** with appropriate fallbacks
- Use **error boundaries** at layout/page level
- Leverage **Suspense** for async rendering

### Performance-First Mindset
- **Server-side optimization**: RSC patterns, caching, streaming
- **Client-side optimization**: Core Web Vitals, bundle size, interactivity
- **Dynamic loading** for non-critical components
- **Optimize images**: WebP format, size data, lazy loading
- **Optimize for Core Web Vitals** (LCP, CLS, FID/INP)
- Use **Turbopack** for faster development builds
- Implement **React Compiler** optimizations when available

### Modern Development Patterns
- Prefer `useActionState` over deprecated `useFormState`
- Implement **stateful URLs** with `@nuqs` for URL state management
- Keep **client-side state minimal and ephemeral**
- Use **React 19 Actions** for form handling and async operations

---

## Domain-Specific Rule References

When working on specific aspects of the frontend, consult these specialized rules:

### TypeScript Standards
- **See: `typescript.mdc`** for comprehensive type safety standards
- **See: `typescript.mdc`** for Zod integration and pure function patterns
- **See: `typescript.mdc`** for React 19 + TypeScript integration

### React 19 Features
- **See: `react19-core-rule.mdc`** for Actions, new hooks, and React 19 APIs
- **See: `react19-core-rule.mdc`** for useActionState, useOptimistic, and use() patterns
- **See: `react19-core-rule.mdc`** for ref as prop and Document Metadata features

### Next.js 15 Features
- **See: `nextjs15-core.rule.mdc`** for async Request APIs and caching changes
- **See: `nextjs15-core.rule.mdc`** for Turbopack, after() API, and authorization patterns
- **See: `nextjs15-core.rule.mdc`** for React Compiler integration and ESLint 9 support

### Component Architecture
- **See: `component-patterns.mdc`** for RSC patterns and shadcn/ui integration
- **See: `component-patterns.mdc`** for error boundaries, Suspense, and accessibility
- **See: `component-patterns.mdc`** for custom hooks and file organization patterns

### Server-Side Performance
- **See: `rsc-performance.mdc`** for React Server Components optimization
- **See: `rsc-performance.mdc`** for server-side caching and data fetching strategies
- **See: `rsc-performance.mdc`** for database optimization and Server Actions patterns

### Client-Side Performance
- **See: `client-performance.mdc`** for Core Web Vitals and bundle optimization
- **See: `client-performance.mdc`** for React Compiler and monitoring strategies
- **See: `client-performance.mdc`** for image optimization and Turbopack integration

### Animation Patterns
- **See: `animation-patterns.mdc`** for motion/react animation standards
- **See: `animation-patterns.mdc`** for performance-optimized animation patterns
- **See: `animation-patterns.mdc`** for accessibility-compliant animations
- **See: `animation-patterns.mdc`** for Tailwind + motion integration guidelines

---

## Quick Reference Checklist

When implementing any frontend feature, ensure:

- ✅ **Server Components by default** - only use `'use client'` when necessary
- ✅ **Suspense boundaries** around async components
- ✅ **Error boundaries** at appropriate levels
- ✅ **Naming conventions** follow kebab-case for files, PascalCase for components
- ✅ **TypeScript strict mode** with proper type definitions
- ✅ **Performance considerations** for images, fonts, and bundle size
- ✅ **Accessibility compliance** with ARIA labels and semantic HTML
- ✅ **Testing strategy** for components and user interactions
- ✅ **Animation guidelines** using motion/react with Tailwind separation
- ✅ **React 19 features** like Actions, useActionState, and useOptimistic

## Integration Guidelines

### shadcn/ui Components
- Compose primitives to build complex UI patterns
- Maintain consistent design system patterns
- Use React Hook Form for form validation and handling
- Follow kebab-case naming for custom components

### State Management Hierarchy
1. **Server State** (RSC) - Preferred for data fetching
2. **URL State** (@nuqs) - For shareable application state
3. **Local State** (useState) - Only for ephemeral UI state
4. **Global State** (Context/Zustand) - Sparingly, for truly global concerns

### File Organization
- Use kebab-case for all file and directory names
- Co-locate related components, hooks, and tests
- Implement barrel exports for clean public APIs
- Follow the established project structure patterns

### Package Management
- Use `pnpm` as the standard package manager
- Leverage pnpm workspaces for monorepo management
- Cache pnpm store for faster CI/CD builds

## Technology Stack Integration

### Core Technologies
- **Frontend**: Next.js 15 + React 19 + TypeScript 5 + Tailwind CSS
- **UI Components**: shadcn/ui + Radix + Lucide icons
- **Animation**: Motion library (motion/react)
- **Linting**: Biome (formatting) + ESLint 9 (React-specific rules)
- **Package Manager**: pnpm

### Development Tools
- **Turbopack**: For faster development builds
- **React Compiler**: Experimental optimization
- **Biome**: Fast formatting and basic linting
- **ESLint**: React/Next.js specific rules and accessibility

## Enterprise Standards Summary

### ✅ ALWAYS DO
- Use TypeScript strict mode with comprehensive types
- Default to Server Components for data fetching
- Implement Server Actions with Zod validation
- Use React 19 hooks: `useActionState`, `useOptimistic`, `useFormStatus`
- Apply Tailwind utilities with shadcn/ui components
- Include proper error boundaries and loading states
- Follow naming conventions consistently
- Implement comprehensive error handling
- Use motion/react for animations with Tailwind for static styles

### ❌ NEVER DO
- Mix `pages/` and `app/` directories
- Use inline styles except for motion animations
- Skip TypeScript types or use `any`
- Bypass Zod validation for user inputs
- Skip error handling in Server Actions
- Use CSS animations when motion/react is available
- Mix animation approaches (CSS + motion for same property)

This orchestrator ensures all specialized rules work together harmoniously while maintaining the structured approach and comprehensive coverage your engineering team needs.
